#!/bin/bash

# 打印用法函数
print_usage() {
    cat << EOF
用法: process_data [选项]

这是一个数据处理脚本，用于组织CSV文件到不同的轮次目录中，并可选择性地进行后续处理。

选项:
  -h, --help            显示此帮助信息并退出
  --main-path PATH      包含目标目录的主目录路径（必需）
  --files-per-round N   每个目录中每轮的文件数量（必需）
  --dir-pattern PAT     需要处理的目录名称正则表达式模式，最后一个捕获组必须是数字（默认: 'node_(\d+)$'）
  --file-pattern PAT    需要处理的文件名正则表达式模式，最后一个捕获组必须是数字（默认: 'rank_(\d+)\.csv$'）
  --new-dir-pattern PAT 新目录的命名模式（默认: 'round_{index}'）
  --no-preserve-prefix  不保留文件名前缀
  
后续处理选项:
  --post-process        启用后续处理：移动文件并提取数据
  --column-name COL     用于过滤的列名（默认: 'Type'）
  --extract-values VAL  要提取的值，可以多次使用（例如: --extract-values "TypeA" --extract-values "TypeB"）
  --sort-column-name COL 用于排序的列名（默认: 'Name'）
  --sort-pattern PAT    排序模式的正则表达式（默认: 最后一个下划线后的数字，即 _(\d+)$）

数据收集选项:
  --gather              启用数据收集：从CSV文件中提取指定列
  --gather-name COLS    要收集的列名，可以指定多个（例如: --gather-name Duration Memory，默认：'Duration(us)'）
  --round-pattern PAT   Round目录的正则表达式模式（默认: 'round_(\d+)$'）
  --step-pattern PAT    Step目录的正则表达式模式（默认: 'step_(\d+)$'）
  --analysis-dir DIR    Analysis目录名称（默认: 'analysis'）

工作原理:
  - 在每个匹配的目录内部，按 files-per-round 个文件为一组进行分割
  - 相同轮次（round）的文件从不同目录合并到同一个 round 目录下
  - 每个 round 目录将包含：目录数量 × files-per-round 个文件
  - 文件在 round 目录中会被连续编号，从 0 开始
  
后续处理（启用 --post-process 时）:
  - 将所有文件移动到 round_index/all_files 目录
  - 根据指定列值提取行，保存到 round_index/analysis/<值名称> 目录
  - 如果指定了sort-column-name，会按照该列的值进行升序分段
  - 每个升序段保存到 round_index/analysis/<值名称>/step_<序号> 目录
  - 提取的文件命名格式：<值名称>_<原文件名>

数据收集（启用 --gather 时）:
  - 遍历所有round目录下的analysis文件夹
  - 对每个子文件夹中的step目录，提取指定列的数据
  - 生成汇总文件：<子文件夹名>_<列名>_step_<step_index>.csv
  - 生成统计文件：<子文件夹名>_<列名>_step_<step_index>_statistics.csv/xlsx

示例:
  # 基本用法（处理 node_0, node_1 等目录）
  ./process_data --main-path /data/csv_files --files-per-round 8
  
  # 启用后续处理，提取Type列中值为"compute"和"communication"的行
  ./process_data --main-path /data/csv_files --files-per-round 8 --post-process --extract-values "compute" --extract-values "communication"
  
  # 使用自定义列名进行提取，并按Name列分段
  ./process_data --main-path /data --files-per-round 10 --post-process --column-name "Category" --extract-values "A" --extract-values "B" --sort-column-name "Name"
  
  # 使用自定义排序模式（例如：提取形如 task_123 中的数字）
  ./process_data --main-path /data --files-per-round 10 --post-process --extract-values "compute" --sort-pattern "task_(\\d+)"
  
  # 仅进行后续处理（假设round目录已存在）
  ./process_data --main-path /data --post-process --extract-values "compute" --extract-values "communication"
  
  # 收集指定列的数据
  ./process_data --main-path /data --gather --gather-name Duration Memory
  
  # 组合使用：处理文件、后续处理、并收集数据
  ./process_data --main-path /data --files-per-round 8 --post-process --extract-values "compute" --gather --gather-name Duration Memory

排序分段示例:
  假设有Name列值为: task_10, task_5, task_20, task_15, task_8, task_25
  使用默认排序模式会提取末尾数字并识别出两个升序段：
  - step_1: task_5, task_8, task_10, task_15, task_20
  - step_2: task_25
EOF
}

# 获取脚本所在目录
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
# process_data在experiment/bin目录下，向上两级到experiment目录
EXPERIMENT_DIR="$(dirname "$SCRIPT_DIR")"
# Python脚本在experiment/tools/profiling目录下
PYTHON_SCRIPT="${EXPERIMENT_DIR}/tools/profiling/separate_rounds.py"
POST_PROCESS_SCRIPT="${EXPERIMENT_DIR}/tools/profiling/post_process_csv.py"
GATHER_SCRIPT="${EXPERIMENT_DIR}/tools/profiling/gather_csv_columns.py"

# 如果没有参数，打印用法
if [ $# -eq 0 ]; then
    print_usage
    exit 0
fi

# 检查是否请求帮助
for arg in "$@"; do
    if [ "$arg" = "-h" ] || [ "$arg" = "--help" ]; then
        print_usage
        exit 0
    fi
done

# 检查是否安装了Python
if ! command -v python &> /dev/null; then
    echo "错误: 需要Python才能运行此脚本"
    exit 1
fi

# 解析参数
MAIN_PATH=""
FILES_PER_ROUND=""
POST_PROCESS=false
GATHER=false
SEPERATE_ARGS=()
POST_PROCESS_ARGS=()
GATHER_ARGS=()
GATHER_NAMES=()

while [[ $# -gt 0 ]]; do
    case $1 in
        --main-path)
            MAIN_PATH="$2"
            SEPERATE_ARGS+=("$1" "$2")
            POST_PROCESS_ARGS+=("$1" "$2")
            GATHER_ARGS+=("$1" "$2")
            shift 2
            ;;
        --files-per-round)
            FILES_PER_ROUND="$2"
            SEPERATE_ARGS+=("$1" "$2")
            shift 2
            ;;
        --dir-pattern|--file-pattern|--new-dir-pattern)
            SEPERATE_ARGS+=("$1" "$2")
            if [[ "$1" == "--new-dir-pattern" ]]; then
                POST_PROCESS_ARGS+=("$1" "$2")
                GATHER_ARGS+=("--round-pattern" "${2/\{index\}/(\d+)}")
            elif [[ "$1" == "--file-pattern" ]]; then
                POST_PROCESS_ARGS+=("$1" "$2")
                GATHER_ARGS+=("$1" "$2")
            fi
            shift 2
            ;;
        --no-preserve-prefix)
            SEPERATE_ARGS+=("$1")
            shift
            ;;
        --post-process)
            POST_PROCESS=true
            shift
            ;;
        --column-name|--sort-column-name|--sort-pattern)
            POST_PROCESS_ARGS+=("$1" "$2")
            shift 2
            ;;
        --extract-values)
            POST_PROCESS_ARGS+=("$1" "$2")
            shift 2
            ;;
        --gather)
            GATHER=true
            shift
            ;;
        --gather-name)
            shift
            # 收集所有非选项参数作为列名
            while [[ $# -gt 0 ]] && [[ "$1" != --* ]]; do
                GATHER_NAMES+=("$1")
                shift
            done
            ;;
        --round-pattern|--step-pattern|--analysis-dir)
            GATHER_ARGS+=("$1" "$2")
            shift 2
            ;;
        *)
            echo "错误: 未知参数 $1"
            print_usage
            exit 1
            ;;
    esac
done

# 检查必需参数
if [ -z "$MAIN_PATH" ]; then
    echo "错误: 必须指定 --main-path"
    print_usage
    exit 1
fi

# 如果不是仅后处理或收集模式，检查files-per-round参数
if [ "$POST_PROCESS" != true ] && [ "$GATHER" != true ] || [ ! -z "$FILES_PER_ROUND" ]; then
    if [ -z "$FILES_PER_ROUND" ]; then
        echo "错误: 必须指定 --files-per-round"
        print_usage
        exit 1
    fi
    
    # 检查 seperate_rounds.py 是否存在
    if [ ! -f "$PYTHON_SCRIPT" ]; then
        echo "错误: 找不到 $PYTHON_SCRIPT"
        echo "请确保 seperate_rounds.py 在 ${EXPERIMENT_DIR}/tools/profiling/ 目录下"
        exit 1
    fi
    
    # 第一步：调用seperate_rounds.py进行初始处理
    echo "执行初始文件分组处理..."
    python "$PYTHON_SCRIPT" "${SEPERATE_ARGS[@]}"
    
    if [ $? -ne 0 ]; then
        echo "错误: seperate_rounds.py 执行失败"
        exit 1
    fi
fi

# 第二步：如果启用了后处理，调用post_process_csv.py
if [ "$POST_PROCESS" = true ]; then
    # 检查 post_process_csv.py 是否存在
    if [ ! -f "$POST_PROCESS_SCRIPT" ]; then
        echo "错误: 找不到 $POST_PROCESS_SCRIPT"
        echo "请确保 post_process_csv.py 在 ${EXPERIMENT_DIR}/tools/profiling/ 目录下"
        exit 1
    fi
    
    echo -e "\n执行CSV文件后处理..."
    python "$POST_PROCESS_SCRIPT" "${POST_PROCESS_ARGS[@]}"
    
    if [ $? -ne 0 ]; then
        echo "错误: post_process_csv.py 执行失败"
        exit 1
    fi
fi

# 第三步：如果启用了数据收集，调用gather_csv_columns.py
if [ "$GATHER" = true ]; then
    # 检查 gather_csv_columns.py 是否存在
    if [ ! -f "$GATHER_SCRIPT" ]; then
        echo "错误: 找不到 $GATHER_SCRIPT"
        echo "请确保 gather_csv_columns.py 在 ${EXPERIMENT_DIR}/tools/profiling/ 目录下"
        exit 1
    fi
    
    echo -e "\n执行数据收集..."
    
    # 如果没有指定列名，直接调用脚本使用默认值
    if [ ${#GATHER_NAMES[@]} -eq 0 ]; then
        echo "使用默认列名收集数据"
        python "$GATHER_SCRIPT" "${GATHER_ARGS[@]}"
        
        if [ $? -ne 0 ]; then
            echo "错误: gather_csv_columns.py 执行失败"
            exit 1
        fi
    else
        # 对每个指定的列名调用gather脚本
        for gather_name in "${GATHER_NAMES[@]}"; do
            echo "收集列: $gather_name"
            python "$GATHER_SCRIPT" "${GATHER_ARGS[@]}" --gather "$gather_name"
            
            if [ $? -ne 0 ]; then
                echo "错误: gather_csv_columns.py 对列 '$gather_name' 执行失败"
                exit 1
            fi
        done
    fi
fi

echo -e "\n处理完成！"