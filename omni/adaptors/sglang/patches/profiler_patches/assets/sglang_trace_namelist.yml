type: "marker"
base_params: { }
targets:
  # conn.py
  # Finish pull kv
  - module: "sglang.srt.disaggregation.datadist.conn:DataDistKVManager"
    function_name: "update_status"
    scope: "sglang.srt.disaggregation.datadist.conn:DataDistKVManager"
    scope_function: "transfer_worker"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      
      if os.getenv('ROLE') == "prefill" and len(args) >= 1:
          raw_request_id = args[0]
          safe_print(trace_output_directory, f"<<<Action: Finish pull kv; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # self.started = False
  - module: "sglang.srt.disaggregation.datadist.conn:DataDistKVSender"
    function_name: "__init__"
    exit_operation: |
      self.started = False

  # Start pull kv
  - module: "sglang.srt.disaggregation.datadist.conn:DataDistKVSender"
    function_name: "send"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory

      if not self.started:
          self.started = True
          raw_request_id = self.bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: Start pull kv; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # decode.py
  # Start append running sequece for decode
  - module: "sglang.srt.managers.schedule_batch:Req"
    function_name: "init_next_round_input"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      
      # The D-side KV cache transmission is complete.
      if os.getenv('ROLE') != "prefill" and self.bootstrap_room:
          raw_request_id = self.bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: Start append running sequece for decode; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # Add need pullling sequence
  - module: "sglang.srt.disaggregation.decode:DecodePreallocQueue"
    function_name: "pop_preallocated"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory

      if result:
          for i, decode_req in enumerate(result):
              # The decode side allocates kv memory and successfully synchronizes with the p side. 
              raw_request_id = decode_req.req.bootstrap_room
              safe_print(trace_output_directory, f"<<<Action: Add need pullling sequence|waiting_pull_len={len(self.queue) + i + 1} ; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # Prefill free kv blocks
  - module: "sglang.srt.disaggregation.prefill:SchedulerDisaggregationPrefillMixin"
    function_name: "process_disagg_prefill_inflight_queue"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      from sglang.srt.managers.schedule_batch import Req
      
      if result and isinstance(result, (list, tuple, set, dict)):
          for req in result:
              if (isinstance(req, Req)):
                  raw_request_id = req.bootstrap_room
                  safe_print(trace_output_directory, f"<<<Action: Prefill free kv blocks; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # serving_chat.py
  # Finish decode pickle and start response
  - module: "sglang.srt.entrypoints.openai.serving_chat:OpenAIServingChat"
    function_name: "_generate_chat_stream"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      
      if os.getenv('ROLE') != "prefill" and len(args) >= 2:
          raw_request_id = args[1].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: Finish decode pickle and start response; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # First decode output token
  # Second  decode output token
  # Finish decode pickle and start response
  - module: "sglang.srt.entrypoints.openai.serving_chat:OpenAIServingChat"
    function_name: "_build_chat_response"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      
      if os.getenv('ROLE') != "prefill" and len(args) >= 1:
          raw_request_id = args[0].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: First decode output token; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
          safe_print(trace_output_directory, f"<<<Action: Second decode output token; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
          safe_print(trace_output_directory, f"<<<Action: Finish decode pickle and start response; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # serving_completions.py
  # Finish decode pickle and start response
  - module: "sglang.srt.entrypoints.openai.serving_completions:OpenAIServingCompletion"
    function_name: "_generate_completion_stream"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory     
      
      if len(args) > 1 and os.getenv('ROLE') != "prefill":
          raw_request_id = args[1].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: Finish decode pickle and start response; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # First decode output token
  # Scend decode output token
  # Finish decode pickle and start response
  - module: "sglang.srt.entrypoints.openai.serving_completions:OpenAIServingCompletion"
    function_name: "_build_completion_response"
    exit_operation: |
      import os, time 
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory     

      if os.getenv('ROLE') != "prefill" and len(args) >= 1:
          raw_request_id = args[0].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: First decode output token; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
          safe_print(trace_output_directory, f"<<<Action: Second decode output token; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
          safe_print(trace_output_directory, f"<<<Action: Finish decode pickle and start response; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
          
  # scheduler.py
  # try to schedule in waiting queue
  - module: "sglang.srt.managers.schedule_policy:PrefillAdder"
    function_name: "add_one_req"
    entry_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory
      
      # try to schedule in waiting queue
      if len(args) >= 1:
          raw_request_id = args[0].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: try to schedule in waiting queue; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
  
  # Prefill get new_blocks
  # success add to seq groups
  - module: "sglang.srt.managers.schedule_batch:ScheduleBatch"
    function_name: "init_new"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory

      if cls and os.getenv('ROLE') == "prefill":
          for req in cls:
              raw_request_id = req.bootstrap_room
              safe_print(trace_output_directory, f"<<<Action: Prefill get new_blocks; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")
              safe_print(trace_output_directory, f"<<<Action: success add to seq groups; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")

  # tokenizer_manager.py
  # Finish process request in prefill engine
  - module: "sglang.srt.managers.tokenizer_manager:TokenizerManager"
    function_name: "_tokenize_one_request"
    exit_operation: |
      import os, time
      from sglang.profiler_patches.utils import ip_str, safe_print, trace_output_directory

      if os.getenv('ROLE') == "prefill" and len(args) >= 1:
          raw_request_id = args[0].bootstrap_room
          safe_print(trace_output_directory, f"<<<Action: Finish process request in prefill engine; Timestamp:{time.time()}; RequestID:{raw_request_id}; Role:{os.getenv('ROLE')}_{ip_str}")